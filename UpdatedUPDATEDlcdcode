#include <Wire.h>
#include <Adafruit_MotorShield.h>
#include "utility/Adafruit_MS_PWMServoDriver.h"
#include <Adafruit_RGBLCDShield.h>

// ==========================
// CONFIGURATION CONSTANTS
// ==========================
#define MOTOR_PORT 2          // Using M3/M4 (Port 2)
const int STEPS_PER_REV = 200;

// --- Tube & Pump Geometry ---
const float d = 0.003;        // Tube inner diameter (m)
const float L = 0.085;        // Occlusion length per revolution (m)
volatile float mL_per_rev = (PI * d * d * L / 4.0) * 1e6; // mL per revolution (physically derived)

// --- Default Settings ---
float rate_mL_min = 50.0;     // Default flow rate (mL/min)
float totalVolume_mL = 25.0;  // Default dose target (mL)
bool directionCW = true;      // CW = Forward
bool isRunning = false;

// --- Derived Variables ---
float infused_mL = 0.0;
long totalSteps = 0;
long stepsTaken = 0;

// --- Timing ---
unsigned long lastStepMicros = 0;
unsigned long stepIntervalMicros = 0;

// ==========================
// INITIALIZE HARDWARE
// ==========================
Adafruit_MotorShield AFMS = Adafruit_MotorShield();
Adafruit_StepperMotor *stepper = AFMS.getStepper(STEPS_PER_REV, MOTOR_PORT);
Adafruit_RGBLCDShield lcd = Adafruit_RGBLCDShield();

// Button bitmasks
#define BTN_RIGHT  0x01
#define BTN_UP     0x02
#define BTN_DOWN   0x04
#define BTN_LEFT   0x08
#define BTN_SELECT 0x10

// Menu
enum MenuItem { MENU_RATE, MENU_VOLUME, MENU_DIR, MENU_STARTSTOP };
MenuItem menu = MENU_RATE;

// ==========================
// FUNCTION DEFINITIONS
// ==========================

// Compute step interval from flow rate
void recomputeInterval() {
  float revsPerMin = rate_mL_min / mL_per_rev;
  float stepsPerSec = (revsPerMin * STEPS_PER_REV) / 60.0;
  if (stepsPerSec < 0.1) stepsPerSec = 0.1;
  stepIntervalMicros = (unsigned long)(1e6 / stepsPerSec);
}

// Convert volume to total steps
long volumeToSteps(float mL) {
  float revs = mL / mL_per_rev;
  return (long)(revs * STEPS_PER_REV + 0.5);
}

// Draw LCD UI
void drawUI() {
  lcd.clear();
  lcd.setCursor(0, 0);

  switch (menu) {
    case MENU_RATE:
      lcd.print("Flow: ");
      lcd.print(rate_mL_min, 1);
      lcd.print(" mL/min");
      break;
    case MENU_VOLUME:
      lcd.print("Vol: ");
      lcd.print(totalVolume_mL, 1);
      lcd.print(" mL");
      break;
    case MENU_DIR:
      lcd.print("Dir: ");
      lcd.print(directionCW ? "FWD" : "REV");
      break;
    case MENU_STARTSTOP:
      lcd.print(isRunning ? "STOP Infusion" : "START Infusion");
      break;
  }

  lcd.setCursor(0, 1);

  if (isRunning) {
    float remaining = totalVolume_mL - infused_mL;
    if (remaining < 0) remaining = 0;
    float rpm = (rate_mL_min / mL_per_rev);
    lcd.print(rpm, 0);
    lcd.print("rpm ");
    lcd.print(remaining, 1);
    lcd.print("mL left");
  } else {
    lcd.print("CW=FWD | Hold=Prime");
  }
}

// Soft start ramp (2 s)
void softStart() {
  const int rampTime = 2000; // ms
  unsigned long start = millis();
  while (millis() - start < rampTime && isRunning) {
    float rampFrac = (millis() - start) / (float)rampTime;
    if (rampFrac < 0.05) rampFrac = 0.05;
    unsigned long adjInterval = (unsigned long)(stepIntervalMicros / rampFrac);

    unsigned long now = micros();
    if (now - lastStepMicros >= adjInterval) {
      lastStepMicros = now;
      stepper->onestep(directionCW ? FORWARD : BACKWARD, DOUBLE);
    }
  }
}

// Handle button inputs
void handleButtons() {
  uint8_t b = lcd.readButtons();
  if (!b) return;

  // Prime (hold SELECT)
  if (b & BTN_SELECT) {
    unsigned long holdStart = millis();
    while (lcd.readButtons() & BTN_SELECT) {
      if (millis() - holdStart > 1000) { // hold >1s
        lcd.clear();
        lcd.print("Priming...");
        unsigned long t0 = millis();
        while (millis() - t0 < 5000) { // 5s prime
          stepper->onestep(FORWARD, DOUBLE);
          delayMicroseconds(1000); // fast stepping
        }
        drawUI();
        return;
      }
    }
  }

  if (b & BTN_RIGHT) {
    menu = (MenuItem)((menu + 1) % 4);
    drawUI(); delay(150);
  }
  if (b & BTN_LEFT) {
    menu = (MenuItem)((menu + 3) % 4);
    drawUI(); delay(150);
  }
  if (b & BTN_UP) {
    switch (menu) {
      case MENU_RATE: rate_mL_min += 5.0; if (rate_mL_min > 500) rate_mL_min = 500; recomputeInterval(); break;
      case MENU_VOLUME: totalVolume_mL += 1.0; if (totalVolume_mL > 2000) totalVolume_mL = 2000; break;
      case MENU_DIR: directionCW = !directionCW; break;
      default: break;
    }
    drawUI(); delay(120);
  }
  if (b & BTN_DOWN) {
    switch (menu) {
      case MENU_RATE: rate_mL_min -= 5.0; if (rate_mL_min < 1.0) rate_mL_min = 1.0; recomputeInterval(); break;
      case MENU_VOLUME: totalVolume_mL -= 1.0; if (totalVolume_mL < 0.5) totalVolume_mL = 0.5; break;
      case MENU_DIR: directionCW = !directionCW; break;
      default: break;
    }
    drawUI(); delay(120);
  }
  if (b & BTN_SELECT) {
    // short press
    if (isRunning) {
      isRunning = false;
    } else {
      isRunning = true;
      infused_mL = 0.0;
      stepsTaken = 0;
      totalSteps = volumeToSteps(totalVolume_mL);
      drawUI();
      softStart(); // ramp up
    }
    drawUI(); delay(200);
  }
}

// ==========================
// MAIN LOOP
// ==========================
void setup() {
  AFMS.begin();
  lcd.begin(16, 2);
  lcd.print("Peristaltic Pump");
  delay(800);
  lcd.clear();
  recomputeInterval();
  drawUI();
}

void loop() {
  handleButtons();
  if (!isRunning) return;

  unsigned long now = micros();
  if (now - lastStepMicros >= stepIntervalMicros) {
    lastStepMicros = now;
    stepper->onestep(directionCW ? FORWARD : BACKWARD, DOUBLE);
    stepsTaken++;

    infused_mL = (stepsTaken / (float)STEPS_PER_REV) * mL_per_rev;

    if (infused_mL >= totalVolume_mL) {
      isRunning = false;
      drawUI();
    }
  }
}
